/**
 * üîì TESTES DE EXPLORA√á√ÉO DE VULNERABILIDADES
 * 
 * Este arquivo demonstra como as vulnerabilidades do c√≥digo original
 * podem ser exploradas, e como a vers√£o segura bloqueia esses ataques.
 */

import { describe, test, expect } from "vitest";
import jwt from "jsonwebtoken";

// ============================================================================
// EXPLOIT 1: Fallback Secret Previs√≠vel
// ============================================================================

describe("VULN: Fallback Secret Attack", () => {
    /**
     * O c√≥digo original usa: process.env.SECRET || "123"
     * Se a env var n√£o estiver setada, qualquer atacante pode forjar tokens
     */

    test("Atacante pode criar token v√°lido com secret '123'", () => {
        const WEAK_SECRET = "123"; // O fallback do c√≥digo original

        // Atacante cria um token de admin
        const maliciousToken = jwt.sign(
            {
                user: {
                    id: "hacker-123",
                    role: "admin",
                    email: "hacker@evil.com"
                }
            },
            WEAK_SECRET
        );

        // Token √© v√°lido se o server usar o fallback
        const decoded = jwt.verify(maliciousToken, WEAK_SECRET);
        expect(decoded).toBeDefined();

        console.log("üî¥ EXPLORADO: Token de admin forjado com sucesso!");
        console.log("   Token:", maliciousToken.substring(0, 50) + "...");
    });
});

// ============================================================================
// EXPLOIT 2: Privilege Escalation via Payload Injection
// ============================================================================

describe("VULN: Privilege Escalation", () => {
    const WEAK_SECRET = "123";

    test("Usu√°rio comum pode se elevar a admin", () => {
        // Cen√°rio: Atacante sabe que a verifica√ß√£o √© apenas: req.user.role === 'admin'

        // Cria token com role de admin diretamente
        const escalatedToken = jwt.sign(
            { role: "admin", id: "attacker" },
            WEAK_SECRET
        );

        const decoded = jwt.verify(escalatedToken, WEAK_SECRET) as any;

        // A l√≥gica original simplesmente confia no token
        const isAdmin = decoded.role === "admin";

        expect(isAdmin).toBe(true);
        console.log("üî¥ EXPLORADO: Privil√©gio escalado de user para admin!");
    });
});

// ============================================================================
// EXPLOIT 3: Payload Structure Confusion
// ============================================================================

describe("VULN: Payload Structure Confusion", () => {
    const WEAK_SECRET = "123";

    test("C√≥digo aceita qualquer estrutura de payload", () => {
        // O c√≥digo original faz: req.user = data.user || data || {}
        // Isso aceita m√∫ltiplas estruturas, criando confus√£o

        // Estrutura 1: { user: { ... } }
        const token1 = jwt.sign({ user: { id: "1", role: "admin" } }, WEAK_SECRET);

        // Estrutura 2: { id: ..., role: ... } (sem wrapper user)
        const token2 = jwt.sign({ id: "2", role: "admin" }, WEAK_SECRET);

        // Estrutura 3: Objeto completamente diferente
        const token3 = jwt.sign({ foo: "bar", role: "admin" }, WEAK_SECRET);

        // Todos s√£o aceitos pelo c√≥digo original
        const decoded1 = jwt.verify(token1, WEAK_SECRET) as any;
        const decoded2 = jwt.verify(token2, WEAK_SECRET) as any;
        const decoded3 = jwt.verify(token3, WEAK_SECRET) as any;

        // Simulando a l√≥gica original
        const user1 = decoded1.user || decoded1 || {};
        const user2 = decoded2.user || decoded2 || {};
        const user3 = decoded3.user || decoded3 || {};

        expect(user1.role).toBe("admin");
        expect(user2.role).toBe("admin");
        expect(user3.role).toBe("admin");

        console.log("üî¥ EXPLORADO: 3 estruturas diferentes aceitas!");
    });
});

// ============================================================================
// EXPLOIT 4: Algorithm None Attack (se n√£o for√ßar algoritmo)
// ============================================================================

describe("VULN: Algorithm Confusion", () => {
    test("Demonstra√ß√£o do 'none' algorithm attack", () => {
        // Em vers√µes antigas ou configura√ß√µes ruins, atacantes podiam
        // criar tokens com algorithm: "none" que eram aceitos

        // Header malicioso
        const maliciousHeader = Buffer.from(
            JSON.stringify({ alg: "none", typ: "JWT" })
        ).toString("base64url");

        // Payload com admin
        const maliciousPayload = Buffer.from(
            JSON.stringify({ sub: "hacker", role: "admin" })
        ).toString("base64url");

        // Token sem assinatura
        const unsignedToken = `${maliciousHeader}.${maliciousPayload}.`;

        console.log("‚ö†Ô∏è  Token 'none' algorithm forjado:");
        console.log("   ", unsignedToken);
        console.log("üìù NOTA: Vers√µes modernas do jsonwebtoken rejeitam isso por padr√£o");
        console.log("   Mas a vers√£o segura FOR√áA algorithms: ['HS256'] como prote√ß√£o extra");

        expect(unsignedToken.endsWith(".")).toBe(true);
    });
});

// ============================================================================
// EXPLOIT 5: Information Leakage via Error Messages
// ============================================================================

describe("VULN: Information Leakage", () => {
    test("C√≥digo original exp√µe stack trace no console.log", () => {
        // O c√≥digo original faz:
        // console.log("token error", e);

        // Isso pode expor:
        // - Detalhes internos da biblioteca
        // - Path de arquivos do servidor
        // - Informa√ß√µes √∫teis para atacantes

        const sensitiveInfo = {
            originalCode: 'console.log("token error", e)',
            risk: "Exp√µe stack trace completo",
            mitigation: "Usar logging estruturado sem expor objeto de erro"
        };

        console.log("üî¥ INFORMATION LEAKAGE:");
        console.log("   C√≥digo vulner√°vel:", sensitiveInfo.originalCode);
        console.log("   Risco:", sensitiveInfo.risk);
        console.log("   Mitiga√ß√£o:", sensitiveInfo.mitigation);

        expect(true).toBe(true); // Teste demonstrativo
    });
});

// ============================================================================
// DEMONSTRA√á√ÉO: VERS√ÉO SEGURA BLOQUEIA TODOS OS ATAQUES
// ============================================================================

describe("SECURE: Prote√ß√µes Implementadas", () => {
    test("Resumo das prote√ß√µes na vers√£o segura", () => {
        const protections = [
            {
                vuln: "Fallback secret '123'",
                fix: "Fail fast se JWT_SECRET n√£o estiver configurado + m√≠nimo 32 chars"
            },
            {
                vuln: "Tipagem 'any' em tudo",
                fix: "Interface AuthenticatedRequest + Zod schema validation"
            },
            {
                vuln: "Aceita qualquer estrutura de payload",
                fix: "JwtPayloadSchema com campos obrigat√≥rios e tipos espec√≠ficos"
            },
            {
                vuln: "req.isAdmin baseado s√≥ no token",
                fix: "Valida√ß√£o de role via enum Zod + middleware separado requireAdmin"
            },
            {
                vuln: "Exp√µe erros no console",
                fix: "Logging estruturado sem expor stack traces"
            },
            {
                vuln: "Sem prote√ß√£o contra 'none' algorithm",
                fix: "algorithms: ['HS256'] for√ßado na verifica√ß√£o"
            }
        ];

        console.log("\n‚úÖ PROTE√á√ïES IMPLEMENTADAS NA VERS√ÉO SEGURA:\n");
        protections.forEach((p, i) => {
            console.log(`${i + 1}. VULNERABILIDADE: ${p.vuln}`);
            console.log(`   CORRE√á√ÉO: ${p.fix}\n`);
        });

        expect(protections.length).toBe(6);
    });
});
