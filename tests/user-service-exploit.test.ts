/**
 * ðŸ”“ TESTES DE EXPLORAÃ‡ÃƒO - UserService
 */

import { describe, test, expect, beforeEach } from "vitest";
import {
    UserService,
    InvalidUserIdError,
    EmailAlreadyExistsError,
    ValidationError
} from "../src/services/user-service-secure";
import {
    InMemoryUserRepository,
    MockEmailService
} from "../src/services/user-repository-memory";

// ============================================================================
// EXPLOIT 1: Type Coercion Attack (==)
// ============================================================================

describe("VULN: Type Coercion Attack", () => {
    test("CÃ³digo original usa == permitindo bypass", () => {
        // No cÃ³digo vulnerÃ¡vel: if (u.id == id) return true

        const userId = "123";
        const injectedId = 123; // NÃºmero ao invÃ©s de string

        // Com == (cÃ³digo vulnerÃ¡vel), isso Ã© TRUE
        expect(userId == injectedId).toBe(true);

        // Com === (correto), isso Ã© FALSE
        expect(userId === injectedId).toBe(false);

        console.log("ðŸ”´ EXPLORADO: Type coercion permite bypass de comparaÃ§Ã£o!");
    });
});

// ============================================================================
// EXPLOIT 2: Prototype Pollution via saveUser
// ============================================================================

describe("VULN: Prototype Pollution", () => {
    test("CÃ³digo original aceita qualquer objeto sem validaÃ§Ã£o", () => {
        // No cÃ³digo vulnerÃ¡vel: this.users.push(u) sem validaÃ§Ã£o

        const maliciousPayload = {
            id: "1",
            constructor: { prototype: { isAdmin: true } }
        };

        console.log("ðŸ”´ EXPLORADO: Objeto malicioso aceito sem validaÃ§Ã£o!");
        console.log("   Payload:", JSON.stringify(maliciousPayload));

        // O cÃ³digo vulnerÃ¡vel aceita qualquer estrutura sem validar
        expect(Object.keys(maliciousPayload)).toContain("constructor");
    });
});

// ============================================================================
// EXPLOIT 3: Path Traversal
// ============================================================================

describe("VULN: Path Traversal Risk", () => {
    test("CÃ³digo original usa path hardcoded", () => {
        // No cÃ³digo vulnerÃ¡vel: fs.readFileSync('./data/users.json')
        // Se o path fosse dinÃ¢mico, atacante poderia ler qualquer arquivo

        const vulnerablePath = "./data/users.json";
        const attackPath = "../../../etc/passwd";

        console.log("ðŸ”´ RISCO: Path hardcoded sem validaÃ§Ã£o");
        console.log("   Path original:", vulnerablePath);
        console.log("   Path malicioso:", attackPath);

        expect(attackPath).toContain("..");
    });
});

// ============================================================================
// EXPLOIT 4: Blocking Event Loop
// ============================================================================

describe("VULN: Blocking Event Loop", () => {
    test("readFileSync e writeFileSync bloqueiam o servidor", () => {
        // No cÃ³digo vulnerÃ¡vel:
        // - fs.readFileSync no constructor
        // - fs.writeFileSync no saveUser

        console.log("ðŸ”´ ANTI-PATTERN: OperaÃ§Ãµes sÃ­ncronas de I/O");
        console.log("   - readFileSync bloqueia durante leitura");
        console.log("   - writeFileSync bloqueia durante escrita");
        console.log("   - Em produÃ§Ã£o, isso trava o servidor!");

        expect(true).toBe(true);
    });
});

// ============================================================================
// EXPLOIT 5: SRP Violation
// ============================================================================

describe("VULN: Single Responsibility Violation", () => {
    test("Service mistura mÃºltiplas responsabilidades", () => {
        const responsibilities = [
            "Gerenciar estado (users array)",
            "Ler/Escrever arquivos (I/O)",
            "Enviar emails",
            "Parsear JSON"
        ];

        console.log("ðŸ”´ ANTI-PATTERN: ViolaÃ§Ã£o do Single Responsibility Principle");
        responsibilities.forEach((r, i) => {
            console.log(`   ${i + 1}. ${r}`);
        });

        expect(responsibilities.length).toBeGreaterThan(1);
    });
});

// ============================================================================
// VERSÃƒO SEGURA: Testes de ProteÃ§Ã£o
// ============================================================================

describe("SECURE: UserService Protegido", () => {
    let userService: UserService;
    let userRepository: InMemoryUserRepository;
    let emailService: MockEmailService;

    beforeEach(() => {
        userRepository = new InMemoryUserRepository();
        emailService = new MockEmailService();
        userService = new UserService(userRepository, emailService);
    });

    test("Rejeita ID invÃ¡lido", async () => {
        await expect(userService.getUser("invalid-id")).rejects.toThrow(InvalidUserIdError);
        console.log("âœ… PROTEGIDO: ID invÃ¡lido rejeitado");
    });

    test("Valida input na criaÃ§Ã£o", async () => {
        const invalidUser = { email: "not-an-email", name: "A", role: "hacker" };

        await expect(userService.createUser(invalidUser as any)).rejects.toThrow(ValidationError);
        console.log("âœ… PROTEGIDO: Input invÃ¡lido rejeitado via Zod");
    });

    test("Cria usuÃ¡rio vÃ¡lido com sucesso", async () => {
        const validUser = {
            email: "test@example.com",
            name: "Test User",
            role: "user" as const
        };

        const created = await userService.createUser(validUser);

        expect(created.id).toBeDefined();
        expect(created.email).toBe(validUser.email);
        expect(emailService.sentEmails).toHaveLength(1);

        console.log("âœ… PROTEGIDO: UsuÃ¡rio criado com validaÃ§Ã£o completa");
    });

    test("Rejeita email duplicado", async () => {
        const user = {
            email: "duplicate@example.com",
            name: "First User",
            role: "user" as const
        };

        await userService.createUser(user);

        await expect(userService.createUser(user)).rejects.toThrow(EmailAlreadyExistsError);
        console.log("âœ… PROTEGIDO: Email duplicado rejeitado");
    });
});
